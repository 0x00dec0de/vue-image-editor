webpackHotUpdate(0,{

/***/ 3:
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.overflow {\\n  overflow: hidden;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/Develop/vue-image-editor/client/app/pages/client/app/pages/edit.vue\"],\"names\":[],\"mappings\":\";AAwWA;EACA,iBAAA;CACA\",\"file\":\"edit.vue\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"full\\\">\\n\\n    <div class=\\\"box2 text-center show-md-under\\\">\\n      <h2 class=\\\"primary-dark\\\">Editor</h2>\\n      <div class=\\\"text-subline center\\\"></div>\\n    </div>\\n\\n    <div class=\\\"row condensed\\\">\\n      <div class=\\\"col-md-6\\\">\\n        <div class=\\\"column\\\">\\n          <div class=\\\"box\\\">\\n            <div class=\\\"preview Frame\\\">\\n              <img class=\\\"background\\\" :src=\\\"frame\\\" alt=\\\"\\\">\\n              <Preview :matrix=\\\"matrix\\\" v-if=\\\"image\\\" ref=\\\"preview\\\" :image=\\\"image\\\" :transform=\\\"transform\\\" @resized=\\\"areaResized\\\" @loaded=\\\"imageLoaded\\\" @moved=\\\"imageMoved\\\" />\\n            </div>\\n          </div>\\n        </div>\\n      </div>\\n      <div class=\\\"col-md-6\\\">\\n        <div class=\\\"column pt3\\\">\\n\\n          <div class=\\\"box image-editor-form relative\\\">\\n\\n            <div class=\\\"pb1 hide-md-under\\\">\\n              <h2 class=\\\"primary-dark\\\">Editor</h2>\\n              <div class=\\\"text-subline\\\"></div>\\n            </div>\\n\\n            <div class=\\\"form-group\\\">\\n              <label>Zoom</label>\\n              <div class=\\\"zoom-control mt2\\\">\\n                <div class=\\\"minus\\\"></div>\\n                <input type=\\\"range\\\" :min=\\\"minZoom\\\" :max=\\\"maxZoom\\\" step=\\\"any\\\" @change=\\\"onZoomEnd\\\" v-model.number=\\\"transform.zoom\\\" :disabled=\\\"!imageReady\\\" />\\n                <div class=\\\"plus\\\"></div>\\n              </div>\\n            </div>\\n\\n            <div class=\\\"mt2 flex-row\\\">\\n              <div class=\\\"btn-icon icon-rotate-left\\\" @click=\\\"rotateMinus\\\" :disabled=\\\"!imageReady\\\"><span>Rotate left</span></div>\\n              <div class=\\\"btn-icon icon-rotate-right\\\" @click=\\\"rotatePlus\\\" :disabled=\\\"!imageReady\\\"><span>Rotate right</span></div>\\n              <div class=\\\"btn-icon icon-flop\\\" @click=\\\"flipY\\\" :disabled=\\\"!imageReady\\\"><span>Flip horizontal</span></div>\\n              <div class=\\\"btn-icon icon-flip\\\" @click=\\\"flipX\\\" :disabled=\\\"!imageReady\\\"><span>Flip vertical</span></div>\\n            </div>\\n\\n            <div class=\\\"mt3 btn-group text-md-center\\\">\\n              <button class=\\\"btn btn-primary btn-loading\\\" :class=\\\"{load: nextLoading}\\\" type=\\\"button\\\" @click=\\\"updateImage\\\" :disabled=\\\"!imageReady\\\">Save</button>\\n            </div>\\n\\n          </div>\\n        </div>\\n      </div>\\n    </div>\\n\\n  </div>\\n</template>\\n\\n<script>\\nimport config from '@/config';\\nimport Preview from '@/components/ui/preview';\\n\\nclass Transform {\\n  constructor(center, matrix){\\n    this.init(center, matrix);\\n  }\\n\\n  init(center, matrix){\\n    if(center) this.center = Object.assign({},center);\\n    if(matrix) this.matrix = Object.assign({},matrix);\\n  }\\n\\n  getOrigins(current){\\n    //переходим в локальную систему кординат\\n    let tr = {x: current.x - this.center.x, y: current.y - this.center.y};\\n    //рассчитываем обратную трансформацию и переходим в нулевую систему кординат\\n    const det = 1/(this.matrix.a*this.matrix.d - this.matrix.c*this.matrix.b);\\n    const x = ( this.matrix.d*(tr.x - this.matrix.tx) - this.matrix.c*(tr.y - this.matrix.ty) ) * det + this.center.x;\\n    const y = (-this.matrix.b*(tr.x - this.matrix.tx) + this.matrix.a*(tr.y - this.matrix.ty) ) * det + this.center.y;\\n    return {x, y};\\n  }\\n\\n  translate(current){\\n    //переходим в локальную систему кординат\\n    const origin = {x: current.x - this.center.x, y: current.y - this.center.y};\\n    //рассчитаем трансформацию и возвращаемся во внешнюю систему кординат\\n    let x = this.matrix.a*origin.x + this.matrix.c*origin.y + this.matrix.tx + this.center.x;\\n    let y = this.matrix.b*origin.x + this.matrix.d*origin.y + this.matrix.ty + this.center.y;\\n    return {x, y};\\n  }\\n}\\n\\nfunction getRotation(deg, matrix = false) {\\n  let rotation = deg%360;\\n  if(deg < 0) rotation = 360 + rotation;\\n  if(rotation == 360) rotation = 0;\\n  return rotation;\\n}\\n\\nfunction getMatrix(transform) {\\n  let scaleX = transform.flop ? transform.zoom : transform.zoom;\\n  let scaleY = transform.flip ? -transform.zoom : transform.zoom;\\n  let tx = transform.x;\\n  let ty = transform.y;\\n  const cos = Math.cos(transform.rotate * Math.PI / 180);\\n  const sin = Math.sin(transform.rotate * Math.PI / 180);\\n  let a = Math.round(cos)*scaleX;\\n  let b = Math.round(sin)*scaleX;\\n  let c = -Math.round(sin)*scaleY;\\n  let d = Math.round(cos)*scaleY;\\n\\n  //flop: a < 0\\n  //flip: d < 0\\n  //rotate: a == 0 && d == 0\\n\\n  return { a, b, c, d, tx, ty };\\n}\\n\\nexport default {\\n  components: { Preview },\\n  data () {\\n    return {\\n      clip: {\\n        top: 0,\\n        right: 0,\\n        bottom: 0,\\n        left: 0\\n      },\\n      type: null,\\n      image: null,\\n      imageReady: false,\\n      imageRect: {},\\n      areaRect: {},\\n      minZoomValues: {},\\n      minZoom: 0.5,\\n      maxZoom: 2,\\n      transform: {\\n        center: {\\n          x: 0,\\n          y: 0,\\n        },\\n        zoom: 1,\\n        rotate: 0,\\n        flip: false,\\n        flop: false,\\n        x: 0,\\n        y: 0\\n      },\\n      loadedTransform: null,\\n      nextLoading: false,\\n      frame: 'assets/images/frame-printme-white.png'\\n    }\\n  },\\n  computed: {\\n    matrix() {\\n      let scaleX = this.transform.flop ? -this.transform.zoom : this.transform.zoom;\\n      let scaleY = this.transform.flip ? -this.transform.zoom : this.transform.zoom;\\n      let tx = this.transform.x;\\n      let ty = this.transform.y;\\n      const cos = Math.cos(this.transform.rotate * Math.PI / 180);\\n      const sin = Math.sin(this.transform.rotate * Math.PI / 180);\\n      let a = Math.round(cos)*scaleX;\\n      let b = Math.round(sin)*scaleX;\\n      let c = -Math.round(sin)*scaleY;\\n      let d = Math.round(cos)*scaleY;\\n\\n      return { a, b, c, d, tx, ty };\\n    }\\n  },\\n  mounted(){\\n    this.image = 'assets/images/demo.jpg';\\n  },\\n  methods: {\\n\\n    imageLoaded(rect){\\n      this.imageReady = true;\\n      this.imageRect = rect;\\n      this.imageRect = {\\n        size: {\\n          width: rect.size.width,\\n          height: rect.size.height\\n        },\\n        center: {\\n          x: rect.center.x,\\n          y: rect.center.y\\n        }\\n      };\\n\\n      this._setMinZoom();\\n      this._setMaxZoom();\\n      this.transform.zoom = this.minZoom;\\n\\n      if(this.loadedTransform) this.transform = this.loadedTransform;\\n      this._translate();\\n    },\\n\\n    _setMinZoom(){\\n      let rotate = this.matrix.c !== 0;\\n      let horizontal = this.imageRect.size.height < this.imageRect.size.width;\\n      let areaSize = (horizontal && !rotate || !horizontal && rotate) ? this.areaRect.size.width : this.areaRect.size.height;\\n      let imageSize = horizontal ? this.imageRect.size.width : this.imageRect.size.height;\\n\\n      this.minZoom = areaSize/imageSize;\\n      if(this.transform.zoom < this.minZoom) this.transform.zoom = this.minZoom;\\n    },\\n\\n    _setMaxZoom(){\\n      this.maxZoom = this.areaRect.size.width/config.image.minResolution;\\n      if(this.transform.zoom > this.maxZoom) this.transform.zoom = this.maxZoom;\\n    },\\n\\n    areaResized(rect){\\n      this.areaRect = rect;\\n      if(this.imageReady) this._translate();\\n    },\\n\\n    onZoomEnd(){\\n      this._translate();\\n    },\\n\\n    flipX(){\\n      this.matrix.b == 0 && this.matrix.c == 0\\n      ? this.transform.flip = !this.transform.flip\\n      : this.transform.flop = !this.transform.flop;\\n    },\\n\\n    flipY(){\\n      this.matrix.b == 0 && this.matrix.c == 0\\n      ? this.transform.flop = !this.transform.flop\\n      : this.transform.flip = !this.transform.flip;\\n    },\\n\\n    rotatePlus(){\\n      this.transform.rotate += 90;\\n      this._setMinZoom();\\n      this._translate();\\n    },\\n\\n    rotateMinus(){\\n      this.transform.rotate -= 90;\\n      this._setMinZoom();\\n      this._translate();\\n    },\\n\\n    imageMoved(translate){\\n      this._translate();\\n    },\\n\\n    _translate(checkAlign = true){\\n      const tr = new Transform(this.transform.center, this.matrix);\\n\\n      //находим координаты, которые, после трансформации, должны совпасть с центром области кропа\\n      const newCenter = tr.getOrigins(this.areaRect.center);\\n      this.transform.center = newCenter;\\n      //пересчитываем смещение для компенсации сдвига центра\\n      this.transform.x = this.areaRect.center.x - newCenter.x;\\n      this.transform.y = this.areaRect.center.y - newCenter.y;\\n\\n      //обновляем координаты центра\\n      tr.init(this.transform.center, this.matrix);\\n\\n      //рассчитываем кординаты верхнего левого и нижнего правого углов изображения, которые получились после применения трансформации\\n      let x0y0 = tr.translate({x: 0, y: 0});\\n      let x1y1 = tr.translate({x: this.imageRect.size.width, y: this.imageRect.size.height});\\n\\n      //находим расположение (относительно области кропа) крайних точек изображения и его размер\\n      let result = {\\n        left: x1y1.x - x0y0.x > 0 ? x0y0.x : x1y1.x,\\n        top: x1y1.y - x0y0.y > 0 ? x0y0.y : x1y1.y,\\n        width: Math.abs(x1y1.x - x0y0.x),\\n        height: Math.abs(x1y1.y - x0y0.y)\\n      };\\n\\n      //находим смещения относительно области кропа и выравниваем изображение, если появились \\\"зазоры\\\"\\n      //align functions\\n      let rightOffset = this.areaRect.size.width - (result.left + result.width);\\n      let bottomOffset = this.areaRect.size.height - (result.top + result.height);\\n\\n      let alignedCenter;\\n\\n\\n      //вырайниваем по горизонтали\\n      if(this.areaRect.size.width - result.width > 1){\\n        //align center X\\n        alignedCenter = tr.getOrigins({x: result.left + result.width/2, y: this.areaRect.center.y});\\n      }else{\\n        //align left\\n        if(result.left > 0){\\n          alignedCenter = tr.getOrigins({x: result.left + this.areaRect.center.x, y: this.areaRect.center.y});\\n        //align right\\n        }else if(rightOffset > 0){\\n          alignedCenter = tr.getOrigins({x: this.areaRect.center.x - rightOffset, y: this.areaRect.center.y});\\n        }\\n      }\\n\\n      if(alignedCenter){\\n        this.transform.center = alignedCenter;\\n        this.transform.x = this.areaRect.center.x - alignedCenter.x;\\n        this.transform.y = this.areaRect.center.y - alignedCenter.y;\\n        tr.init(this.transform.center, this.matrix);\\n      }\\n\\n      //вырайниваем по вертикали\\n      if(this.areaRect.size.height - result.height > 1){\\n        //align center Y\\n        alignedCenter = tr.getOrigins({x: this.areaRect.center.x, y: result.top + result.height/2});\\n      }else{\\n        //align top\\n        if(result.top > 0){\\n          alignedCenter = tr.getOrigins({x: this.areaRect.center.x, y: result.top + this.areaRect.center.y});\\n        //align bottom\\n        }else if(bottomOffset > 0){\\n          alignedCenter = tr.getOrigins({x: this.areaRect.center.x, y: this.areaRect.center.y - bottomOffset});\\n        }\\n      }\\n\\n      if(alignedCenter){\\n        this.transform.center = alignedCenter;\\n        this.transform.x = this.areaRect.center.x - alignedCenter.x;\\n        this.transform.y = this.areaRect.center.y - alignedCenter.y;\\n        tr.init(this.transform.center, this.matrix);\\n      }\\n\\n    },\\n\\n    updateImage(){\\n      const tr = new Transform(this.transform.center, this.matrix);\\n      let topLeft = tr.getOrigins({x: 0, y: 0});\\n      let bottomRight = tr.getOrigins({x: this.areaRect.size.width, y: this.areaRect.size.height});\\n\\n      const left = topLeft.x < bottomRight.x ? Math.round(topLeft.x) : Math.round(bottomRight.x);\\n      const top = topLeft.y < bottomRight.y ? Math.round(topLeft.y) : Math.round(bottomRight.y);\\n      const width = Math.round(Math.abs(bottomRight.x - topLeft.x));\\n      const height = Math.round(Math.abs(bottomRight.y - topLeft.y));\\n\\n      const data = {\\n        transform: this.transform,\\n        crop: {\\n          size: this.imageRect.size,\\n          original: this.transform,\\n          flip: this.transform.flip,\\n          flop: this.transform.flop,\\n          rotate: this.transform.rotate,\\n          crop: { left, top, width, height }\\n        }\\n      };\\n\\n      this.nextLoading = true;\\n\\n      console.log(data)\\n      alert(JSON.stringify(data))\\n      //some API\\n\\n      this.nextLoading = false;\\n    }\\n\\n  }\\n}\\n</script>\\n\\n<style lang=\\\"css\\\">\\n  .overflow {\\n    overflow: hidden;\\n  }\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jbGllbnQvYXBwL3BhZ2VzL2VkaXQudnVlP2I3MDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxzQ0FBdUMscUJBQXFCLEdBQUcsVUFBVSx1SEFBdUgsTUFBTSxXQUFXLDBvRUFBMG9FLGtCQUFrQix3T0FBd08sZ0RBQWdELHFCQUFxQixnQ0FBZ0MsZ0NBQWdDLEtBQUssMkJBQTJCLCtDQUErQyxTQUFTLCtDQUErQyxTQUFTLEtBQUssMEJBQTBCLDhEQUE4RCw0REFBNEQsa0tBQWtLLHdIQUF3SCx3SEFBd0gsY0FBYyxNQUFNLEtBQUsseUJBQXlCLG9FQUFvRSw0REFBNEQsMEtBQTBLLCtGQUErRixjQUFjLE1BQU0sS0FBSyxHQUFHLCtDQUErQywyQkFBMkIsMENBQTBDLHFDQUFxQyxvQkFBb0IsR0FBRyxtQ0FBbUMsa0VBQWtFLG1FQUFtRSx5QkFBeUIseUJBQXlCLDJEQUEyRCwyREFBMkQsbUNBQW1DLG1DQUFtQyxvQ0FBb0MsbUNBQW1DLGdGQUFnRixzQkFBc0IsR0FBRyxvQkFBb0IsaUJBQWlCLFVBQVUsY0FBYyxjQUFjLGVBQWUsa0ZBQWtGLHVGQUF1RixxQkFBcUIsMEJBQTBCLDZEQUE2RCxtQkFBbUIsNkNBQTZDLHlIQUF5SCx1SEFBdUgsS0FBSyxnQkFBZ0IsZ0JBQWdCLHNGQUFzRixzRkFBc0Ysa0NBQWtDLGtDQUFrQyxvRUFBb0Usb0VBQW9FLHVDQUF1Qyx1Q0FBdUMsd0NBQXdDLHVDQUF1QyxrQkFBa0Isc0JBQXNCLE9BQU8sS0FBSyxlQUFlLDRDQUE0QyxLQUFLLGVBQWUsMEJBQTBCLCtCQUErQiw4QkFBOEIsMEJBQTBCLGlCQUFpQixrRkFBa0Ysb0JBQW9CLG9FQUFvRSxVQUFVLDZCQUE2QiwyQkFBMkIsMkNBQTJDLHlFQUF5RSwwQkFBMEIsT0FBTyx1QkFBdUIseUNBQXlDLGdGQUFnRiwrSEFBK0gsNEZBQTRGLDRDQUE0QyxrRkFBa0YsT0FBTyx1QkFBdUIsMkVBQTJFLGtGQUFrRixPQUFPLDJCQUEyQiw2QkFBNkIsOENBQThDLE9BQU8scUJBQXFCLDBCQUEwQixPQUFPLGlCQUFpQix5SkFBeUosT0FBTyxpQkFBaUIseUpBQXlKLE9BQU8sc0JBQXNCLG9DQUFvQywyQkFBMkIsMEJBQTBCLE9BQU8sdUJBQXVCLG9DQUFvQywyQkFBMkIsMEJBQTBCLE9BQU8sK0JBQStCLDBCQUEwQixPQUFPLHVDQUF1QyxxRUFBcUUsbUtBQW1LLDBDQUEwQyw4SEFBOEgsZ0VBQWdFLDJGQUEyRiwwS0FBMEssV0FBVyxFQUFFLGlDQUFpQyw0REFBNEQsRUFBRSwwSEFBMEgsMk1BQTJNLHVOQUF1TixvRkFBb0YsNEJBQTRCLGdHQUFnRyxtRUFBbUUsMkRBQTJELEVBQUUsU0FBUyxLQUFLLG9EQUFvRCwyQ0FBMkMsbUVBQW1FLEVBQUUsa0NBQWtDLHlCQUF5QiwyQ0FBMkMsbUVBQW1FLEVBQUUsV0FBVyxTQUFTLDRCQUE0QixnREFBZ0Qsc0VBQXNFLHNFQUFzRSxzREFBc0QsU0FBUyw4RkFBOEYsbUVBQW1FLDJEQUEyRCxFQUFFLFNBQVMsS0FBSyxrREFBa0QsMkNBQTJDLGtFQUFrRSxFQUFFLG1DQUFtQywwQkFBMEIsMkNBQTJDLG9FQUFvRSxFQUFFLFdBQVcsU0FBUyw0QkFBNEIsZ0RBQWdELHNFQUFzRSxzRUFBc0Usc0RBQXNELFNBQVMsU0FBUyx1QkFBdUIscUVBQXFFLHFDQUFxQyxXQUFXLEVBQUUseUNBQXlDLDBEQUEwRCxFQUFFLHFHQUFxRyxrR0FBa0csc0VBQXNFLHVFQUF1RSx3QkFBd0IscURBQXFELG9OQUFvTiwyQkFBMkIsV0FBVyxVQUFVLGtDQUFrQyxtSEFBbUgsT0FBTyxPQUFPLEdBQUcsa0RBQWtELHVCQUF1QixLQUFLLCtCQUErQjs7QUFFcHhZIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLm92ZXJmbG93IHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvRGV2ZWxvcC92dWUtaW1hZ2UtZWRpdG9yL2NsaWVudC9hcHAvcGFnZXMvY2xpZW50L2FwcC9wYWdlcy9lZGl0LnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBd1dBO0VBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiZWRpdC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwiZnVsbFxcXCI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImJveDIgdGV4dC1jZW50ZXIgc2hvdy1tZC11bmRlclxcXCI+XFxuICAgICAgPGgyIGNsYXNzPVxcXCJwcmltYXJ5LWRhcmtcXFwiPkVkaXRvcjwvaDI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dC1zdWJsaW5lIGNlbnRlclxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgY29uZGVuc2VkXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2x1bW5cXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3hcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByZXZpZXcgRnJhbWVcXFwiPlxcbiAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwiYmFja2dyb3VuZFxcXCIgOnNyYz1cXFwiZnJhbWVcXFwiIGFsdD1cXFwiXFxcIj5cXG4gICAgICAgICAgICAgIDxQcmV2aWV3IDptYXRyaXg9XFxcIm1hdHJpeFxcXCIgdi1pZj1cXFwiaW1hZ2VcXFwiIHJlZj1cXFwicHJldmlld1xcXCIgOmltYWdlPVxcXCJpbWFnZVxcXCIgOnRyYW5zZm9ybT1cXFwidHJhbnNmb3JtXFxcIiBAcmVzaXplZD1cXFwiYXJlYVJlc2l6ZWRcXFwiIEBsb2FkZWQ9XFxcImltYWdlTG9hZGVkXFxcIiBAbW92ZWQ9XFxcImltYWdlTW92ZWRcXFwiIC8+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sdW1uIHB0M1xcXCI+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBpbWFnZS1lZGl0b3ItZm9ybSByZWxhdGl2ZVxcXCI+XFxuXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGIxIGhpZGUtbWQtdW5kZXJcXFwiPlxcbiAgICAgICAgICAgICAgPGgyIGNsYXNzPVxcXCJwcmltYXJ5LWRhcmtcXFwiPkVkaXRvcjwvaDI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0LXN1YmxpbmVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgPGxhYmVsPlpvb208L2xhYmVsPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiem9vbS1jb250cm9sIG10MlxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1pbnVzXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhbmdlXFxcIiA6bWluPVxcXCJtaW5ab29tXFxcIiA6bWF4PVxcXCJtYXhab29tXFxcIiBzdGVwPVxcXCJhbnlcXFwiIEBjaGFuZ2U9XFxcIm9uWm9vbUVuZFxcXCIgdi1tb2RlbC5udW1iZXI9XFxcInRyYW5zZm9ybS56b29tXFxcIiA6ZGlzYWJsZWQ9XFxcIiFpbWFnZVJlYWR5XFxcIiAvPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwbHVzXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm10MiBmbGV4LXJvd1xcXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4taWNvbiBpY29uLXJvdGF0ZS1sZWZ0XFxcIiBAY2xpY2s9XFxcInJvdGF0ZU1pbnVzXFxcIiA6ZGlzYWJsZWQ9XFxcIiFpbWFnZVJlYWR5XFxcIj48c3Bhbj5Sb3RhdGUgbGVmdDwvc3Bhbj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1pY29uIGljb24tcm90YXRlLXJpZ2h0XFxcIiBAY2xpY2s9XFxcInJvdGF0ZVBsdXNcXFwiIDpkaXNhYmxlZD1cXFwiIWltYWdlUmVhZHlcXFwiPjxzcGFuPlJvdGF0ZSByaWdodDwvc3Bhbj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1pY29uIGljb24tZmxvcFxcXCIgQGNsaWNrPVxcXCJmbGlwWVxcXCIgOmRpc2FibGVkPVxcXCIhaW1hZ2VSZWFkeVxcXCI+PHNwYW4+RmxpcCBob3Jpem9udGFsPC9zcGFuPjwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWljb24gaWNvbi1mbGlwXFxcIiBAY2xpY2s9XFxcImZsaXBYXFxcIiA6ZGlzYWJsZWQ9XFxcIiFpbWFnZVJlYWR5XFxcIj48c3Bhbj5GbGlwIHZlcnRpY2FsPC9zcGFuPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm10MyBidG4tZ3JvdXAgdGV4dC1tZC1jZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1sb2FkaW5nXFxcIiA6Y2xhc3M9XFxcIntsb2FkOiBuZXh0TG9hZGluZ31cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgQGNsaWNrPVxcXCJ1cGRhdGVJbWFnZVxcXCIgOmRpc2FibGVkPVxcXCIhaW1hZ2VSZWFkeVxcXCI+U2F2ZTwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgY29uZmlnIGZyb20gJ0AvY29uZmlnJztcXG5pbXBvcnQgUHJldmlldyBmcm9tICdAL2NvbXBvbmVudHMvdWkvcHJldmlldyc7XFxuXFxuY2xhc3MgVHJhbnNmb3JtIHtcXG4gIGNvbnN0cnVjdG9yKGNlbnRlciwgbWF0cml4KXtcXG4gICAgdGhpcy5pbml0KGNlbnRlciwgbWF0cml4KTtcXG4gIH1cXG5cXG4gIGluaXQoY2VudGVyLCBtYXRyaXgpe1xcbiAgICBpZihjZW50ZXIpIHRoaXMuY2VudGVyID0gT2JqZWN0LmFzc2lnbih7fSxjZW50ZXIpO1xcbiAgICBpZihtYXRyaXgpIHRoaXMubWF0cml4ID0gT2JqZWN0LmFzc2lnbih7fSxtYXRyaXgpO1xcbiAgfVxcblxcbiAgZ2V0T3JpZ2lucyhjdXJyZW50KXtcXG4gICAgLy/Qv9C10YDQtdGF0L7QtNC40Lwg0LIg0LvQvtC60LDQu9GM0L3Rg9GOINGB0LjRgdGC0LXQvNGDINC60L7RgNC00LjQvdCw0YJcXG4gICAgbGV0IHRyID0ge3g6IGN1cnJlbnQueCAtIHRoaXMuY2VudGVyLngsIHk6IGN1cnJlbnQueSAtIHRoaXMuY2VudGVyLnl9O1xcbiAgICAvL9GA0LDRgdGB0YfQuNGC0YvQstCw0LXQvCDQvtCx0YDQsNGC0L3Rg9GOINGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNGOINC4INC/0LXRgNC10YXQvtC00LjQvCDQsiDQvdGD0LvQtdCy0YPRjiDRgdC40YHRgtC10LzRgyDQutC+0YDQtNC40L3QsNGCXFxuICAgIGNvbnN0IGRldCA9IDEvKHRoaXMubWF0cml4LmEqdGhpcy5tYXRyaXguZCAtIHRoaXMubWF0cml4LmMqdGhpcy5tYXRyaXguYik7XFxuICAgIGNvbnN0IHggPSAoIHRoaXMubWF0cml4LmQqKHRyLnggLSB0aGlzLm1hdHJpeC50eCkgLSB0aGlzLm1hdHJpeC5jKih0ci55IC0gdGhpcy5tYXRyaXgudHkpICkgKiBkZXQgKyB0aGlzLmNlbnRlci54O1xcbiAgICBjb25zdCB5ID0gKC10aGlzLm1hdHJpeC5iKih0ci54IC0gdGhpcy5tYXRyaXgudHgpICsgdGhpcy5tYXRyaXguYSoodHIueSAtIHRoaXMubWF0cml4LnR5KSApICogZGV0ICsgdGhpcy5jZW50ZXIueTtcXG4gICAgcmV0dXJuIHt4LCB5fTtcXG4gIH1cXG5cXG4gIHRyYW5zbGF0ZShjdXJyZW50KXtcXG4gICAgLy/Qv9C10YDQtdGF0L7QtNC40Lwg0LIg0LvQvtC60LDQu9GM0L3Rg9GOINGB0LjRgdGC0LXQvNGDINC60L7RgNC00LjQvdCw0YJcXG4gICAgY29uc3Qgb3JpZ2luID0ge3g6IGN1cnJlbnQueCAtIHRoaXMuY2VudGVyLngsIHk6IGN1cnJlbnQueSAtIHRoaXMuY2VudGVyLnl9O1xcbiAgICAvL9GA0LDRgdGB0YfQuNGC0LDQtdC8INGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNGOINC4INCy0L7Qt9Cy0YDQsNGJ0LDQtdC80YHRjyDQstC+INCy0L3QtdGI0L3RjtGOINGB0LjRgdGC0LXQvNGDINC60L7RgNC00LjQvdCw0YJcXG4gICAgbGV0IHggPSB0aGlzLm1hdHJpeC5hKm9yaWdpbi54ICsgdGhpcy5tYXRyaXguYypvcmlnaW4ueSArIHRoaXMubWF0cml4LnR4ICsgdGhpcy5jZW50ZXIueDtcXG4gICAgbGV0IHkgPSB0aGlzLm1hdHJpeC5iKm9yaWdpbi54ICsgdGhpcy5tYXRyaXguZCpvcmlnaW4ueSArIHRoaXMubWF0cml4LnR5ICsgdGhpcy5jZW50ZXIueTtcXG4gICAgcmV0dXJuIHt4LCB5fTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0Um90YXRpb24oZGVnLCBtYXRyaXggPSBmYWxzZSkge1xcbiAgbGV0IHJvdGF0aW9uID0gZGVnJTM2MDtcXG4gIGlmKGRlZyA8IDApIHJvdGF0aW9uID0gMzYwICsgcm90YXRpb247XFxuICBpZihyb3RhdGlvbiA9PSAzNjApIHJvdGF0aW9uID0gMDtcXG4gIHJldHVybiByb3RhdGlvbjtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0TWF0cml4KHRyYW5zZm9ybSkge1xcbiAgbGV0IHNjYWxlWCA9IHRyYW5zZm9ybS5mbG9wID8gdHJhbnNmb3JtLnpvb20gOiB0cmFuc2Zvcm0uem9vbTtcXG4gIGxldCBzY2FsZVkgPSB0cmFuc2Zvcm0uZmxpcCA/IC10cmFuc2Zvcm0uem9vbSA6IHRyYW5zZm9ybS56b29tO1xcbiAgbGV0IHR4ID0gdHJhbnNmb3JtLng7XFxuICBsZXQgdHkgPSB0cmFuc2Zvcm0ueTtcXG4gIGNvbnN0IGNvcyA9IE1hdGguY29zKHRyYW5zZm9ybS5yb3RhdGUgKiBNYXRoLlBJIC8gMTgwKTtcXG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKHRyYW5zZm9ybS5yb3RhdGUgKiBNYXRoLlBJIC8gMTgwKTtcXG4gIGxldCBhID0gTWF0aC5yb3VuZChjb3MpKnNjYWxlWDtcXG4gIGxldCBiID0gTWF0aC5yb3VuZChzaW4pKnNjYWxlWDtcXG4gIGxldCBjID0gLU1hdGgucm91bmQoc2luKSpzY2FsZVk7XFxuICBsZXQgZCA9IE1hdGgucm91bmQoY29zKSpzY2FsZVk7XFxuXFxuICAvL2Zsb3A6IGEgPCAwXFxuICAvL2ZsaXA6IGQgPCAwXFxuICAvL3JvdGF0ZTogYSA9PSAwICYmIGQgPT0gMFxcblxcbiAgcmV0dXJuIHsgYSwgYiwgYywgZCwgdHgsIHR5IH07XFxufVxcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIGNvbXBvbmVudHM6IHsgUHJldmlldyB9LFxcbiAgZGF0YSAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY2xpcDoge1xcbiAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgcmlnaHQ6IDAsXFxuICAgICAgICBib3R0b206IDAsXFxuICAgICAgICBsZWZ0OiAwXFxuICAgICAgfSxcXG4gICAgICB0eXBlOiBudWxsLFxcbiAgICAgIGltYWdlOiBudWxsLFxcbiAgICAgIGltYWdlUmVhZHk6IGZhbHNlLFxcbiAgICAgIGltYWdlUmVjdDoge30sXFxuICAgICAgYXJlYVJlY3Q6IHt9LFxcbiAgICAgIG1pblpvb21WYWx1ZXM6IHt9LFxcbiAgICAgIG1pblpvb206IDAuNSxcXG4gICAgICBtYXhab29tOiAyLFxcbiAgICAgIHRyYW5zZm9ybToge1xcbiAgICAgICAgY2VudGVyOiB7XFxuICAgICAgICAgIHg6IDAsXFxuICAgICAgICAgIHk6IDAsXFxuICAgICAgICB9LFxcbiAgICAgICAgem9vbTogMSxcXG4gICAgICAgIHJvdGF0ZTogMCxcXG4gICAgICAgIGZsaXA6IGZhbHNlLFxcbiAgICAgICAgZmxvcDogZmFsc2UsXFxuICAgICAgICB4OiAwLFxcbiAgICAgICAgeTogMFxcbiAgICAgIH0sXFxuICAgICAgbG9hZGVkVHJhbnNmb3JtOiBudWxsLFxcbiAgICAgIG5leHRMb2FkaW5nOiBmYWxzZSxcXG4gICAgICBmcmFtZTogJ2Fzc2V0cy9pbWFnZXMvZnJhbWUtcHJpbnRtZS13aGl0ZS5wbmcnXFxuICAgIH1cXG4gIH0sXFxuICBjb21wdXRlZDoge1xcbiAgICBtYXRyaXgoKSB7XFxuICAgICAgbGV0IHNjYWxlWCA9IHRoaXMudHJhbnNmb3JtLmZsb3AgPyAtdGhpcy50cmFuc2Zvcm0uem9vbSA6IHRoaXMudHJhbnNmb3JtLnpvb207XFxuICAgICAgbGV0IHNjYWxlWSA9IHRoaXMudHJhbnNmb3JtLmZsaXAgPyAtdGhpcy50cmFuc2Zvcm0uem9vbSA6IHRoaXMudHJhbnNmb3JtLnpvb207XFxuICAgICAgbGV0IHR4ID0gdGhpcy50cmFuc2Zvcm0ueDtcXG4gICAgICBsZXQgdHkgPSB0aGlzLnRyYW5zZm9ybS55O1xcbiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHRoaXMudHJhbnNmb3JtLnJvdGF0ZSAqIE1hdGguUEkgLyAxODApO1xcbiAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHRoaXMudHJhbnNmb3JtLnJvdGF0ZSAqIE1hdGguUEkgLyAxODApO1xcbiAgICAgIGxldCBhID0gTWF0aC5yb3VuZChjb3MpKnNjYWxlWDtcXG4gICAgICBsZXQgYiA9IE1hdGgucm91bmQoc2luKSpzY2FsZVg7XFxuICAgICAgbGV0IGMgPSAtTWF0aC5yb3VuZChzaW4pKnNjYWxlWTtcXG4gICAgICBsZXQgZCA9IE1hdGgucm91bmQoY29zKSpzY2FsZVk7XFxuXFxuICAgICAgcmV0dXJuIHsgYSwgYiwgYywgZCwgdHgsIHR5IH07XFxuICAgIH1cXG4gIH0sXFxuICBtb3VudGVkKCl7XFxuICAgIHRoaXMuaW1hZ2UgPSAnYXNzZXRzL2ltYWdlcy9kZW1vLmpwZyc7XFxuICB9LFxcbiAgbWV0aG9kczoge1xcblxcbiAgICBpbWFnZUxvYWRlZChyZWN0KXtcXG4gICAgICB0aGlzLmltYWdlUmVhZHkgPSB0cnVlO1xcbiAgICAgIHRoaXMuaW1hZ2VSZWN0ID0gcmVjdDtcXG4gICAgICB0aGlzLmltYWdlUmVjdCA9IHtcXG4gICAgICAgIHNpemU6IHtcXG4gICAgICAgICAgd2lkdGg6IHJlY3Quc2l6ZS53aWR0aCxcXG4gICAgICAgICAgaGVpZ2h0OiByZWN0LnNpemUuaGVpZ2h0XFxuICAgICAgICB9LFxcbiAgICAgICAgY2VudGVyOiB7XFxuICAgICAgICAgIHg6IHJlY3QuY2VudGVyLngsXFxuICAgICAgICAgIHk6IHJlY3QuY2VudGVyLnlcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3NldE1pblpvb20oKTtcXG4gICAgICB0aGlzLl9zZXRNYXhab29tKCk7XFxuICAgICAgdGhpcy50cmFuc2Zvcm0uem9vbSA9IHRoaXMubWluWm9vbTtcXG5cXG4gICAgICBpZih0aGlzLmxvYWRlZFRyYW5zZm9ybSkgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLmxvYWRlZFRyYW5zZm9ybTtcXG4gICAgICB0aGlzLl90cmFuc2xhdGUoKTtcXG4gICAgfSxcXG5cXG4gICAgX3NldE1pblpvb20oKXtcXG4gICAgICBsZXQgcm90YXRlID0gdGhpcy5tYXRyaXguYyAhPT0gMDtcXG4gICAgICBsZXQgaG9yaXpvbnRhbCA9IHRoaXMuaW1hZ2VSZWN0LnNpemUuaGVpZ2h0IDwgdGhpcy5pbWFnZVJlY3Quc2l6ZS53aWR0aDtcXG4gICAgICBsZXQgYXJlYVNpemUgPSAoaG9yaXpvbnRhbCAmJiAhcm90YXRlIHx8ICFob3Jpem9udGFsICYmIHJvdGF0ZSkgPyB0aGlzLmFyZWFSZWN0LnNpemUud2lkdGggOiB0aGlzLmFyZWFSZWN0LnNpemUuaGVpZ2h0O1xcbiAgICAgIGxldCBpbWFnZVNpemUgPSBob3Jpem9udGFsID8gdGhpcy5pbWFnZVJlY3Quc2l6ZS53aWR0aCA6IHRoaXMuaW1hZ2VSZWN0LnNpemUuaGVpZ2h0O1xcblxcbiAgICAgIHRoaXMubWluWm9vbSA9IGFyZWFTaXplL2ltYWdlU2l6ZTtcXG4gICAgICBpZih0aGlzLnRyYW5zZm9ybS56b29tIDwgdGhpcy5taW5ab29tKSB0aGlzLnRyYW5zZm9ybS56b29tID0gdGhpcy5taW5ab29tO1xcbiAgICB9LFxcblxcbiAgICBfc2V0TWF4Wm9vbSgpe1xcbiAgICAgIHRoaXMubWF4Wm9vbSA9IHRoaXMuYXJlYVJlY3Quc2l6ZS53aWR0aC9jb25maWcuaW1hZ2UubWluUmVzb2x1dGlvbjtcXG4gICAgICBpZih0aGlzLnRyYW5zZm9ybS56b29tID4gdGhpcy5tYXhab29tKSB0aGlzLnRyYW5zZm9ybS56b29tID0gdGhpcy5tYXhab29tO1xcbiAgICB9LFxcblxcbiAgICBhcmVhUmVzaXplZChyZWN0KXtcXG4gICAgICB0aGlzLmFyZWFSZWN0ID0gcmVjdDtcXG4gICAgICBpZih0aGlzLmltYWdlUmVhZHkpIHRoaXMuX3RyYW5zbGF0ZSgpO1xcbiAgICB9LFxcblxcbiAgICBvblpvb21FbmQoKXtcXG4gICAgICB0aGlzLl90cmFuc2xhdGUoKTtcXG4gICAgfSxcXG5cXG4gICAgZmxpcFgoKXtcXG4gICAgICB0aGlzLm1hdHJpeC5iID09IDAgJiYgdGhpcy5tYXRyaXguYyA9PSAwXFxuICAgICAgPyB0aGlzLnRyYW5zZm9ybS5mbGlwID0gIXRoaXMudHJhbnNmb3JtLmZsaXBcXG4gICAgICA6IHRoaXMudHJhbnNmb3JtLmZsb3AgPSAhdGhpcy50cmFuc2Zvcm0uZmxvcDtcXG4gICAgfSxcXG5cXG4gICAgZmxpcFkoKXtcXG4gICAgICB0aGlzLm1hdHJpeC5iID09IDAgJiYgdGhpcy5tYXRyaXguYyA9PSAwXFxuICAgICAgPyB0aGlzLnRyYW5zZm9ybS5mbG9wID0gIXRoaXMudHJhbnNmb3JtLmZsb3BcXG4gICAgICA6IHRoaXMudHJhbnNmb3JtLmZsaXAgPSAhdGhpcy50cmFuc2Zvcm0uZmxpcDtcXG4gICAgfSxcXG5cXG4gICAgcm90YXRlUGx1cygpe1xcbiAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0ZSArPSA5MDtcXG4gICAgICB0aGlzLl9zZXRNaW5ab29tKCk7XFxuICAgICAgdGhpcy5fdHJhbnNsYXRlKCk7XFxuICAgIH0sXFxuXFxuICAgIHJvdGF0ZU1pbnVzKCl7XFxuICAgICAgdGhpcy50cmFuc2Zvcm0ucm90YXRlIC09IDkwO1xcbiAgICAgIHRoaXMuX3NldE1pblpvb20oKTtcXG4gICAgICB0aGlzLl90cmFuc2xhdGUoKTtcXG4gICAgfSxcXG5cXG4gICAgaW1hZ2VNb3ZlZCh0cmFuc2xhdGUpe1xcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZSgpO1xcbiAgICB9LFxcblxcbiAgICBfdHJhbnNsYXRlKGNoZWNrQWxpZ24gPSB0cnVlKXtcXG4gICAgICBjb25zdCB0ciA9IG5ldyBUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB0aGlzLm1hdHJpeCk7XFxuXFxuICAgICAgLy/QvdCw0YXQvtC00LjQvCDQutC+0L7RgNC00LjQvdCw0YLRiywg0LrQvtGC0L7RgNGL0LUsINC/0L7RgdC70LUg0YLRgNCw0L3RgdGE0L7RgNC80LDRhtC40LgsINC00L7Qu9C20L3RiyDRgdC+0LLQv9Cw0YHRgtGMINGBINGG0LXQvdGC0YDQvtC8INC+0LHQu9Cw0YHRgtC4INC60YDQvtC/0LBcXG4gICAgICBjb25zdCBuZXdDZW50ZXIgPSB0ci5nZXRPcmlnaW5zKHRoaXMuYXJlYVJlY3QuY2VudGVyKTtcXG4gICAgICB0aGlzLnRyYW5zZm9ybS5jZW50ZXIgPSBuZXdDZW50ZXI7XFxuICAgICAgLy/Qv9C10YDQtdGB0YfQuNGC0YvQstCw0LXQvCDRgdC80LXRidC10L3QuNC1INC00LvRjyDQutC+0LzQv9C10L3RgdCw0YbQuNC4INGB0LTQstC40LPQsCDRhtC10L3RgtGA0LBcXG4gICAgICB0aGlzLnRyYW5zZm9ybS54ID0gdGhpcy5hcmVhUmVjdC5jZW50ZXIueCAtIG5ld0NlbnRlci54O1xcbiAgICAgIHRoaXMudHJhbnNmb3JtLnkgPSB0aGlzLmFyZWFSZWN0LmNlbnRlci55IC0gbmV3Q2VudGVyLnk7XFxuXFxuICAgICAgLy/QvtCx0L3QvtCy0LvRj9C10Lwg0LrQvtC+0YDQtNC40L3QsNGC0Ysg0YbQtdC90YLRgNCwXFxuICAgICAgdHIuaW5pdCh0aGlzLnRyYW5zZm9ybS5jZW50ZXIsIHRoaXMubWF0cml4KTtcXG5cXG4gICAgICAvL9GA0LDRgdGB0YfQuNGC0YvQstCw0LXQvCDQutC+0YDQtNC40L3QsNGC0Ysg0LLQtdGA0YXQvdC10LPQviDQu9C10LLQvtCz0L4g0Lgg0L3QuNC20L3QtdCz0L4g0L/RgNCw0LLQvtCz0L4g0YPQs9C70L7QsiDQuNC30L7QsdGA0LDQttC10L3QuNGPLCDQutC+0YLQvtGA0YvQtSDQv9C+0LvRg9GH0LjQu9C40YHRjCDQv9C+0YHQu9C1INC/0YDQuNC80LXQvdC10L3QuNGPINGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNC4XFxuICAgICAgbGV0IHgweTAgPSB0ci50cmFuc2xhdGUoe3g6IDAsIHk6IDB9KTtcXG4gICAgICBsZXQgeDF5MSA9IHRyLnRyYW5zbGF0ZSh7eDogdGhpcy5pbWFnZVJlY3Quc2l6ZS53aWR0aCwgeTogdGhpcy5pbWFnZVJlY3Quc2l6ZS5oZWlnaHR9KTtcXG5cXG4gICAgICAvL9C90LDRhdC+0LTQuNC8INGA0LDRgdC/0L7Qu9C+0LbQtdC90LjQtSAo0L7RgtC90L7RgdC40YLQtdC70YzQvdC+INC+0LHQu9Cw0YHRgtC4INC60YDQvtC/0LApINC60YDQsNC50L3QuNGFINGC0L7Rh9C10Log0LjQt9C+0LHRgNCw0LbQtdC90LjRjyDQuCDQtdCz0L4g0YDQsNC30LzQtdGAXFxuICAgICAgbGV0IHJlc3VsdCA9IHtcXG4gICAgICAgIGxlZnQ6IHgxeTEueCAtIHgweTAueCA+IDAgPyB4MHkwLnggOiB4MXkxLngsXFxuICAgICAgICB0b3A6IHgxeTEueSAtIHgweTAueSA+IDAgPyB4MHkwLnkgOiB4MXkxLnksXFxuICAgICAgICB3aWR0aDogTWF0aC5hYnMoeDF5MS54IC0geDB5MC54KSxcXG4gICAgICAgIGhlaWdodDogTWF0aC5hYnMoeDF5MS55IC0geDB5MC55KVxcbiAgICAgIH07XFxuXFxuICAgICAgLy/QvdCw0YXQvtC00LjQvCDRgdC80LXRidC10L3QuNGPINC+0YLQvdC+0YHQuNGC0LXQu9GM0L3QviDQvtCx0LvQsNGB0YLQuCDQutGA0L7Qv9CwINC4INCy0YvRgNCw0LLQvdC40LLQsNC10Lwg0LjQt9C+0LHRgNCw0LbQtdC90LjQtSwg0LXRgdC70Lgg0L/QvtGP0LLQuNC70LjRgdGMIFxcXCLQt9Cw0LfQvtGA0YtcXFwiXFxuICAgICAgLy9hbGlnbiBmdW5jdGlvbnNcXG4gICAgICBsZXQgcmlnaHRPZmZzZXQgPSB0aGlzLmFyZWFSZWN0LnNpemUud2lkdGggLSAocmVzdWx0LmxlZnQgKyByZXN1bHQud2lkdGgpO1xcbiAgICAgIGxldCBib3R0b21PZmZzZXQgPSB0aGlzLmFyZWFSZWN0LnNpemUuaGVpZ2h0IC0gKHJlc3VsdC50b3AgKyByZXN1bHQuaGVpZ2h0KTtcXG5cXG4gICAgICBsZXQgYWxpZ25lZENlbnRlcjtcXG5cXG5cXG4gICAgICAvL9Cy0YvRgNCw0LnQvdC40LLQsNC10Lwg0L/QviDQs9C+0YDQuNC30L7QvdGC0LDQu9C4XFxuICAgICAgaWYodGhpcy5hcmVhUmVjdC5zaXplLndpZHRoIC0gcmVzdWx0LndpZHRoID4gMSl7XFxuICAgICAgICAvL2FsaWduIGNlbnRlciBYXFxuICAgICAgICBhbGlnbmVkQ2VudGVyID0gdHIuZ2V0T3JpZ2lucyh7eDogcmVzdWx0LmxlZnQgKyByZXN1bHQud2lkdGgvMiwgeTogdGhpcy5hcmVhUmVjdC5jZW50ZXIueX0pO1xcbiAgICAgIH1lbHNle1xcbiAgICAgICAgLy9hbGlnbiBsZWZ0XFxuICAgICAgICBpZihyZXN1bHQubGVmdCA+IDApe1xcbiAgICAgICAgICBhbGlnbmVkQ2VudGVyID0gdHIuZ2V0T3JpZ2lucyh7eDogcmVzdWx0LmxlZnQgKyB0aGlzLmFyZWFSZWN0LmNlbnRlci54LCB5OiB0aGlzLmFyZWFSZWN0LmNlbnRlci55fSk7XFxuICAgICAgICAvL2FsaWduIHJpZ2h0XFxuICAgICAgICB9ZWxzZSBpZihyaWdodE9mZnNldCA+IDApe1xcbiAgICAgICAgICBhbGlnbmVkQ2VudGVyID0gdHIuZ2V0T3JpZ2lucyh7eDogdGhpcy5hcmVhUmVjdC5jZW50ZXIueCAtIHJpZ2h0T2Zmc2V0LCB5OiB0aGlzLmFyZWFSZWN0LmNlbnRlci55fSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmKGFsaWduZWRDZW50ZXIpe1xcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uY2VudGVyID0gYWxpZ25lZENlbnRlcjtcXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnggPSB0aGlzLmFyZWFSZWN0LmNlbnRlci54IC0gYWxpZ25lZENlbnRlci54O1xcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ueSA9IHRoaXMuYXJlYVJlY3QuY2VudGVyLnkgLSBhbGlnbmVkQ2VudGVyLnk7XFxuICAgICAgICB0ci5pbml0KHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdGhpcy5tYXRyaXgpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvL9Cy0YvRgNCw0LnQvdC40LLQsNC10Lwg0L/QviDQstC10YDRgtC40LrQsNC70LhcXG4gICAgICBpZih0aGlzLmFyZWFSZWN0LnNpemUuaGVpZ2h0IC0gcmVzdWx0LmhlaWdodCA+IDEpe1xcbiAgICAgICAgLy9hbGlnbiBjZW50ZXIgWVxcbiAgICAgICAgYWxpZ25lZENlbnRlciA9IHRyLmdldE9yaWdpbnMoe3g6IHRoaXMuYXJlYVJlY3QuY2VudGVyLngsIHk6IHJlc3VsdC50b3AgKyByZXN1bHQuaGVpZ2h0LzJ9KTtcXG4gICAgICB9ZWxzZXtcXG4gICAgICAgIC8vYWxpZ24gdG9wXFxuICAgICAgICBpZihyZXN1bHQudG9wID4gMCl7XFxuICAgICAgICAgIGFsaWduZWRDZW50ZXIgPSB0ci5nZXRPcmlnaW5zKHt4OiB0aGlzLmFyZWFSZWN0LmNlbnRlci54LCB5OiByZXN1bHQudG9wICsgdGhpcy5hcmVhUmVjdC5jZW50ZXIueX0pO1xcbiAgICAgICAgLy9hbGlnbiBib3R0b21cXG4gICAgICAgIH1lbHNlIGlmKGJvdHRvbU9mZnNldCA+IDApe1xcbiAgICAgICAgICBhbGlnbmVkQ2VudGVyID0gdHIuZ2V0T3JpZ2lucyh7eDogdGhpcy5hcmVhUmVjdC5jZW50ZXIueCwgeTogdGhpcy5hcmVhUmVjdC5jZW50ZXIueSAtIGJvdHRvbU9mZnNldH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZihhbGlnbmVkQ2VudGVyKXtcXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmNlbnRlciA9IGFsaWduZWRDZW50ZXI7XFxuICAgICAgICB0aGlzLnRyYW5zZm9ybS54ID0gdGhpcy5hcmVhUmVjdC5jZW50ZXIueCAtIGFsaWduZWRDZW50ZXIueDtcXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnkgPSB0aGlzLmFyZWFSZWN0LmNlbnRlci55IC0gYWxpZ25lZENlbnRlci55O1xcbiAgICAgICAgdHIuaW5pdCh0aGlzLnRyYW5zZm9ybS5jZW50ZXIsIHRoaXMubWF0cml4KTtcXG4gICAgICB9XFxuXFxuICAgIH0sXFxuXFxuICAgIHVwZGF0ZUltYWdlKCl7XFxuICAgICAgY29uc3QgdHIgPSBuZXcgVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdGhpcy5tYXRyaXgpO1xcbiAgICAgIGxldCB0b3BMZWZ0ID0gdHIuZ2V0T3JpZ2lucyh7eDogMCwgeTogMH0pO1xcbiAgICAgIGxldCBib3R0b21SaWdodCA9IHRyLmdldE9yaWdpbnMoe3g6IHRoaXMuYXJlYVJlY3Quc2l6ZS53aWR0aCwgeTogdGhpcy5hcmVhUmVjdC5zaXplLmhlaWdodH0pO1xcblxcbiAgICAgIGNvbnN0IGxlZnQgPSB0b3BMZWZ0LnggPCBib3R0b21SaWdodC54ID8gTWF0aC5yb3VuZCh0b3BMZWZ0LngpIDogTWF0aC5yb3VuZChib3R0b21SaWdodC54KTtcXG4gICAgICBjb25zdCB0b3AgPSB0b3BMZWZ0LnkgPCBib3R0b21SaWdodC55ID8gTWF0aC5yb3VuZCh0b3BMZWZ0LnkpIDogTWF0aC5yb3VuZChib3R0b21SaWdodC55KTtcXG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoTWF0aC5hYnMoYm90dG9tUmlnaHQueCAtIHRvcExlZnQueCkpO1xcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5hYnMoYm90dG9tUmlnaHQueSAtIHRvcExlZnQueSkpO1xcblxcbiAgICAgIGNvbnN0IGRhdGEgPSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMudHJhbnNmb3JtLFxcbiAgICAgICAgY3JvcDoge1xcbiAgICAgICAgICBzaXplOiB0aGlzLmltYWdlUmVjdC5zaXplLFxcbiAgICAgICAgICBvcmlnaW5hbDogdGhpcy50cmFuc2Zvcm0sXFxuICAgICAgICAgIGZsaXA6IHRoaXMudHJhbnNmb3JtLmZsaXAsXFxuICAgICAgICAgIGZsb3A6IHRoaXMudHJhbnNmb3JtLmZsb3AsXFxuICAgICAgICAgIHJvdGF0ZTogdGhpcy50cmFuc2Zvcm0ucm90YXRlLFxcbiAgICAgICAgICBjcm9wOiB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLm5leHRMb2FkaW5nID0gdHJ1ZTtcXG5cXG4gICAgICBjb25zb2xlLmxvZyhkYXRhKVxcbiAgICAgIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGRhdGEpKVxcbiAgICAgIC8vc29tZSBBUElcXG5cXG4gICAgICB0aGlzLm5leHRMb2FkaW5nID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gIH1cXG59XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlIGxhbmc9XFxcImNzc1xcXCI+XFxuICAub3ZlcmZsb3cge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTk2MzNhNjZlXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2FwcC9wYWdlcy9lZGl0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),

/***/ 9:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_ui_preview__ = __webpack_require__(19);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\nclass Transform {\n  constructor(center, matrix) {\n    this.init(center, matrix);\n  }\n\n  init(center, matrix) {\n    if (center) this.center = Object.assign({}, center);\n    if (matrix) this.matrix = Object.assign({}, matrix);\n  }\n\n  getOrigins(current) {\n    //переходим в локальную систему кординат\n    let tr = { x: current.x - this.center.x, y: current.y - this.center.y };\n    //рассчитываем обратную трансформацию и переходим в нулевую систему кординат\n    const det = 1 / (this.matrix.a * this.matrix.d - this.matrix.c * this.matrix.b);\n    const x = (this.matrix.d * (tr.x - this.matrix.tx) - this.matrix.c * (tr.y - this.matrix.ty)) * det + this.center.x;\n    const y = (-this.matrix.b * (tr.x - this.matrix.tx) + this.matrix.a * (tr.y - this.matrix.ty)) * det + this.center.y;\n    return { x, y };\n  }\n\n  translate(current) {\n    //переходим в локальную систему кординат\n    const origin = { x: current.x - this.center.x, y: current.y - this.center.y };\n    //рассчитаем трансформацию и возвращаемся во внешнюю систему кординат\n    let x = this.matrix.a * origin.x + this.matrix.c * origin.y + this.matrix.tx + this.center.x;\n    let y = this.matrix.b * origin.x + this.matrix.d * origin.y + this.matrix.ty + this.center.y;\n    return { x, y };\n  }\n}\n\nfunction getRotation(deg, matrix = false) {\n  let rotation = deg % 360;\n  if (deg < 0) rotation = 360 + rotation;\n  if (rotation == 360) rotation = 0;\n  return rotation;\n}\n\nfunction getMatrix(transform) {\n  let scaleX = transform.flop ? transform.zoom : transform.zoom;\n  let scaleY = transform.flip ? -transform.zoom : transform.zoom;\n  let tx = transform.x;\n  let ty = transform.y;\n  const cos = Math.cos(transform.rotate * Math.PI / 180);\n  const sin = Math.sin(transform.rotate * Math.PI / 180);\n  let a = Math.round(cos) * scaleX;\n  let b = Math.round(sin) * scaleX;\n  let c = -Math.round(sin) * scaleY;\n  let d = Math.round(cos) * scaleY;\n\n  //flop: a < 0\n  //flip: d < 0\n  //rotate: a == 0 && d == 0\n\n  return { a, b, c, d, tx, ty };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  components: { Preview: __WEBPACK_IMPORTED_MODULE_1__components_ui_preview__[\"a\" /* default */] },\n  data() {\n    return {\n      clip: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      type: null,\n      image: null,\n      imageReady: false,\n      imageRect: {},\n      areaRect: {},\n      minZoomValues: {},\n      minZoom: 0.5,\n      maxZoom: 2,\n      transform: {\n        center: {\n          x: 0,\n          y: 0\n        },\n        zoom: 1,\n        rotate: 0,\n        flip: false,\n        flop: false,\n        x: 0,\n        y: 0\n      },\n      loadedTransform: null,\n      nextLoading: false,\n      frame: 'assets/images/frame-printme-white.png'\n    };\n  },\n  computed: {\n    matrix() {\n      let scaleX = this.transform.flop ? -this.transform.zoom : this.transform.zoom;\n      let scaleY = this.transform.flip ? -this.transform.zoom : this.transform.zoom;\n      let tx = this.transform.x;\n      let ty = this.transform.y;\n      const cos = Math.cos(this.transform.rotate * Math.PI / 180);\n      const sin = Math.sin(this.transform.rotate * Math.PI / 180);\n      let a = Math.round(cos) * scaleX;\n      let b = Math.round(sin) * scaleX;\n      let c = -Math.round(sin) * scaleY;\n      let d = Math.round(cos) * scaleY;\n\n      return { a, b, c, d, tx, ty };\n    }\n  },\n  mounted() {\n    this.image = 'assets/images/demo.jpg';\n  },\n  methods: {\n\n    imageLoaded(rect) {\n      this.imageReady = true;\n      this.imageRect = rect;\n      this.imageRect = {\n        size: {\n          width: rect.size.width,\n          height: rect.size.height\n        },\n        center: {\n          x: rect.center.x,\n          y: rect.center.y\n        }\n      };\n\n      this._setMinZoom();\n      this._setMaxZoom();\n      this.transform.zoom = this.minZoom;\n\n      if (this.loadedTransform) this.transform = this.loadedTransform;\n      this._translate();\n    },\n\n    _setMinZoom() {\n      let rotate = this.matrix.c !== 0;\n      let horizontal = this.imageRect.size.height < this.imageRect.size.width;\n      let areaSize = horizontal && !rotate || !horizontal && rotate ? this.areaRect.size.width : this.areaRect.size.height;\n      let imageSize = horizontal ? this.imageRect.size.width : this.imageRect.size.height;\n\n      this.minZoom = areaSize / imageSize;\n      if (this.transform.zoom < this.minZoom) this.transform.zoom = this.minZoom;\n    },\n\n    _setMaxZoom() {\n      this.maxZoom = this.areaRect.size.width / __WEBPACK_IMPORTED_MODULE_0__config__[\"a\" /* default */].image.minResolution;\n      if (this.transform.zoom > this.maxZoom) this.transform.zoom = this.maxZoom;\n    },\n\n    areaResized(rect) {\n      this.areaRect = rect;\n      if (this.imageReady) this._translate();\n    },\n\n    onZoomEnd() {\n      this._translate();\n    },\n\n    flipX() {\n      this.matrix.b == 0 && this.matrix.c == 0 ? this.transform.flip = !this.transform.flip : this.transform.flop = !this.transform.flop;\n    },\n\n    flipY() {\n      this.matrix.b == 0 && this.matrix.c == 0 ? this.transform.flop = !this.transform.flop : this.transform.flip = !this.transform.flip;\n    },\n\n    rotatePlus() {\n      this.transform.rotate += 90;\n      this._setMinZoom();\n      this._translate();\n    },\n\n    rotateMinus() {\n      this.transform.rotate -= 90;\n      this._setMinZoom();\n      this._translate();\n    },\n\n    imageMoved(translate) {\n      this._translate();\n    },\n\n    _translate(checkAlign = true) {\n      const tr = new Transform(this.transform.center, this.matrix);\n\n      //находим координаты, которые, после трансформации, должны совпасть с центром области кропа\n      const newCenter = tr.getOrigins(this.areaRect.center);\n      this.transform.center = newCenter;\n      //пересчитываем смещение для компенсации сдвига центра\n      this.transform.x = this.areaRect.center.x - newCenter.x;\n      this.transform.y = this.areaRect.center.y - newCenter.y;\n\n      //обновляем координаты центра\n      tr.init(this.transform.center, this.matrix);\n\n      //рассчитываем кординаты верхнего левого и нижнего правого углов изображения, которые получились после применения трансформации\n      let x0y0 = tr.translate({ x: 0, y: 0 });\n      let x1y1 = tr.translate({ x: this.imageRect.size.width, y: this.imageRect.size.height });\n\n      //находим расположение (относительно области кропа) крайних точек изображения и его размер\n      let result = {\n        left: x1y1.x - x0y0.x > 0 ? x0y0.x : x1y1.x,\n        top: x1y1.y - x0y0.y > 0 ? x0y0.y : x1y1.y,\n        width: Math.abs(x1y1.x - x0y0.x),\n        height: Math.abs(x1y1.y - x0y0.y)\n      };\n\n      //находим смещения относительно области кропа и выравниваем изображение, если появились \"зазоры\"\n      //align functions\n      let rightOffset = this.areaRect.size.width - (result.left + result.width);\n      let bottomOffset = this.areaRect.size.height - (result.top + result.height);\n\n      let alignedCenter;\n\n      //вырайниваем по горизонтали\n      if (this.areaRect.size.width - result.width > 1) {\n        //align center X\n        alignedCenter = tr.getOrigins({ x: result.left + result.width / 2, y: this.areaRect.center.y });\n      } else {\n        //align left\n        if (result.left > 0) {\n          alignedCenter = tr.getOrigins({ x: result.left + this.areaRect.center.x, y: this.areaRect.center.y });\n          //align right\n        } else if (rightOffset > 0) {\n          alignedCenter = tr.getOrigins({ x: this.areaRect.center.x - rightOffset, y: this.areaRect.center.y });\n        }\n      }\n\n      if (alignedCenter) {\n        this.transform.center = alignedCenter;\n        this.transform.x = this.areaRect.center.x - alignedCenter.x;\n        this.transform.y = this.areaRect.center.y - alignedCenter.y;\n        tr.init(this.transform.center, this.matrix);\n      }\n\n      //вырайниваем по вертикали\n      if (this.areaRect.size.height - result.height > 1) {\n        //align center Y\n        alignedCenter = tr.getOrigins({ x: this.areaRect.center.x, y: result.top + result.height / 2 });\n      } else {\n        //align top\n        if (result.top > 0) {\n          alignedCenter = tr.getOrigins({ x: this.areaRect.center.x, y: result.top + this.areaRect.center.y });\n          //align bottom\n        } else if (bottomOffset > 0) {\n          alignedCenter = tr.getOrigins({ x: this.areaRect.center.x, y: this.areaRect.center.y - bottomOffset });\n        }\n      }\n\n      if (alignedCenter) {\n        this.transform.center = alignedCenter;\n        this.transform.x = this.areaRect.center.x - alignedCenter.x;\n        this.transform.y = this.areaRect.center.y - alignedCenter.y;\n        tr.init(this.transform.center, this.matrix);\n      }\n    },\n\n    updateImage() {\n      const tr = new Transform(this.transform.center, this.matrix);\n      let topLeft = tr.getOrigins({ x: 0, y: 0 });\n      let bottomRight = tr.getOrigins({ x: this.areaRect.size.width, y: this.areaRect.size.height });\n\n      const left = topLeft.x < bottomRight.x ? Math.round(topLeft.x) : Math.round(bottomRight.x);\n      const top = topLeft.y < bottomRight.y ? Math.round(topLeft.y) : Math.round(bottomRight.y);\n      const width = Math.round(Math.abs(bottomRight.x - topLeft.x));\n      const height = Math.round(Math.abs(bottomRight.y - topLeft.y));\n\n      const data = {\n        transform: this.transform,\n        crop: {\n          size: this.imageRect.size,\n          original: this.transform,\n          flip: this.transform.flip,\n          flop: this.transform.flop,\n          rotate: this.transform.rotate,\n          crop: { left, top, width, height }\n        }\n      };\n\n      this.nextLoading = true;\n\n      console.log(data);\n      alert(JSON.stringify(data));\n      //some API\n\n      this.nextLoading = false;\n    }\n\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY2xpZW50L2FwcC9wYWdlcy9lZGl0LnZ1ZT85ZTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBOztBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtHQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FEQTtBQUVBLGdCQUZBO0FBR0EsaUJBSEE7QUFJQTtBQUpBLE9BREE7QUFPQSxnQkFQQTtBQVFBLGlCQVJBO0FBU0EsdUJBVEE7QUFVQSxtQkFWQTtBQVdBLGtCQVhBO0FBWUEsdUJBWkE7QUFhQSxrQkFiQTtBQWNBLGdCQWRBO0FBZUE7QUFDQTtBQUNBLGNBREE7QUFFQTtBQUZBLFNBREE7QUFLQSxlQUxBO0FBTUEsaUJBTkE7QUFPQSxtQkFQQTtBQVFBLG1CQVJBO0FBU0EsWUFUQTtBQVVBO0FBVkEsT0FmQTtBQTJCQSwyQkEzQkE7QUE0QkEsd0JBNUJBO0FBNkJBO0FBN0JBO0FBK0JBLEdBbENBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBZEEsR0FuQ0E7QUFtREE7QUFDQTtBQUNBLEdBckRBO0FBc0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FEQTtBQUVBO0FBRkEsU0FEQTtBQUtBO0FBQ0EsMEJBREE7QUFFQTtBQUZBO0FBTEE7O0FBV0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQXRCQTs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FoQ0E7O0FBa0NBO0FBQ0E7QUFDQTtBQUNBLEtBckNBOztBQXVDQTtBQUNBO0FBQ0E7QUFDQSxLQTFDQTs7QUE0Q0E7QUFDQTtBQUNBLEtBOUNBOztBQWdEQTtBQUNBLGlEQUNBLDBDQURBLEdBRUEsMENBRkE7QUFHQSxLQXBEQTs7QUFzREE7QUFDQSxpREFDQSwwQ0FEQSxHQUVBLDBDQUZBO0FBR0EsS0ExREE7O0FBNERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FoRUE7O0FBa0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0F0RUE7O0FBd0VBO0FBQ0E7QUFDQSxLQTFFQTs7QUE0RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQURBO0FBRUEsa0RBRkE7QUFHQSx3Q0FIQTtBQUlBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUhBLE1BR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSEEsTUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUhBLE1BR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSEEsTUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxLQXZKQTs7QUF5SkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FEQTtBQUVBO0FBQ0EsbUNBREE7QUFFQSxrQ0FGQTtBQUdBLG1DQUhBO0FBSUEsbUNBSkE7QUFLQSx1Q0FMQTtBQU1BO0FBTkE7QUFGQTs7QUFZQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUF0TEE7QUF0REEiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImZ1bGxcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJib3gyIHRleHQtY2VudGVyIHNob3ctbWQtdW5kZXJcIj5cbiAgICAgIDxoMiBjbGFzcz1cInByaW1hcnktZGFya1wiPkVkaXRvcjwvaDI+XG4gICAgICA8ZGl2IGNsYXNzPVwidGV4dC1zdWJsaW5lIGNlbnRlclwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInJvdyBjb25kZW5zZWRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImJveFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInByZXZpZXcgRnJhbWVcIj5cbiAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImJhY2tncm91bmRcIiA6c3JjPVwiZnJhbWVcIiBhbHQ9XCJcIj5cbiAgICAgICAgICAgICAgPFByZXZpZXcgOm1hdHJpeD1cIm1hdHJpeFwiIHYtaWY9XCJpbWFnZVwiIHJlZj1cInByZXZpZXdcIiA6aW1hZ2U9XCJpbWFnZVwiIDp0cmFuc2Zvcm09XCJ0cmFuc2Zvcm1cIiBAcmVzaXplZD1cImFyZWFSZXNpemVkXCIgQGxvYWRlZD1cImltYWdlTG9hZGVkXCIgQG1vdmVkPVwiaW1hZ2VNb3ZlZFwiIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIHB0M1wiPlxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImJveCBpbWFnZS1lZGl0b3ItZm9ybSByZWxhdGl2ZVwiPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGIxIGhpZGUtbWQtdW5kZXJcIj5cbiAgICAgICAgICAgICAgPGgyIGNsYXNzPVwicHJpbWFyeS1kYXJrXCI+RWRpdG9yPC9oMj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtc3VibGluZVwiPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAgICAgICAgIDxsYWJlbD5ab29tPC9sYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb20tY29udHJvbCBtdDJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWludXNcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgOm1pbj1cIm1pblpvb21cIiA6bWF4PVwibWF4Wm9vbVwiIHN0ZXA9XCJhbnlcIiBAY2hhbmdlPVwib25ab29tRW5kXCIgdi1tb2RlbC5udW1iZXI9XCJ0cmFuc2Zvcm0uem9vbVwiIDpkaXNhYmxlZD1cIiFpbWFnZVJlYWR5XCIgLz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGx1c1wiPjwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXQyIGZsZXgtcm93XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4taWNvbiBpY29uLXJvdGF0ZS1sZWZ0XCIgQGNsaWNrPVwicm90YXRlTWludXNcIiA6ZGlzYWJsZWQ9XCIhaW1hZ2VSZWFkeVwiPjxzcGFuPlJvdGF0ZSBsZWZ0PC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWljb24gaWNvbi1yb3RhdGUtcmlnaHRcIiBAY2xpY2s9XCJyb3RhdGVQbHVzXCIgOmRpc2FibGVkPVwiIWltYWdlUmVhZHlcIj48c3Bhbj5Sb3RhdGUgcmlnaHQ8L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4taWNvbiBpY29uLWZsb3BcIiBAY2xpY2s9XCJmbGlwWVwiIDpkaXNhYmxlZD1cIiFpbWFnZVJlYWR5XCI+PHNwYW4+RmxpcCBob3Jpem9udGFsPC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWljb24gaWNvbi1mbGlwXCIgQGNsaWNrPVwiZmxpcFhcIiA6ZGlzYWJsZWQ9XCIhaW1hZ2VSZWFkeVwiPjxzcGFuPkZsaXAgdmVydGljYWw8L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10MyBidG4tZ3JvdXAgdGV4dC1tZC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tbG9hZGluZ1wiIDpjbGFzcz1cIntsb2FkOiBuZXh0TG9hZGluZ31cIiB0eXBlPVwiYnV0dG9uXCIgQGNsaWNrPVwidXBkYXRlSW1hZ2VcIiA6ZGlzYWJsZWQ9XCIhaW1hZ2VSZWFkeVwiPlNhdmU8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGNvbmZpZyBmcm9tICdAL2NvbmZpZyc7XG5pbXBvcnQgUHJldmlldyBmcm9tICdAL2NvbXBvbmVudHMvdWkvcHJldmlldyc7XG5cbmNsYXNzIFRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yKGNlbnRlciwgbWF0cml4KXtcbiAgICB0aGlzLmluaXQoY2VudGVyLCBtYXRyaXgpO1xuICB9XG5cbiAgaW5pdChjZW50ZXIsIG1hdHJpeCl7XG4gICAgaWYoY2VudGVyKSB0aGlzLmNlbnRlciA9IE9iamVjdC5hc3NpZ24oe30sY2VudGVyKTtcbiAgICBpZihtYXRyaXgpIHRoaXMubWF0cml4ID0gT2JqZWN0LmFzc2lnbih7fSxtYXRyaXgpO1xuICB9XG5cbiAgZ2V0T3JpZ2lucyhjdXJyZW50KXtcbiAgICAvL9C/0LXRgNC10YXQvtC00LjQvCDQsiDQu9C+0LrQsNC70YzQvdGD0Y4g0YHQuNGB0YLQtdC80YMg0LrQvtGA0LTQuNC90LDRglxuICAgIGxldCB0ciA9IHt4OiBjdXJyZW50LnggLSB0aGlzLmNlbnRlci54LCB5OiBjdXJyZW50LnkgLSB0aGlzLmNlbnRlci55fTtcbiAgICAvL9GA0LDRgdGB0YfQuNGC0YvQstCw0LXQvCDQvtCx0YDQsNGC0L3Rg9GOINGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNGOINC4INC/0LXRgNC10YXQvtC00LjQvCDQsiDQvdGD0LvQtdCy0YPRjiDRgdC40YHRgtC10LzRgyDQutC+0YDQtNC40L3QsNGCXG4gICAgY29uc3QgZGV0ID0gMS8odGhpcy5tYXRyaXguYSp0aGlzLm1hdHJpeC5kIC0gdGhpcy5tYXRyaXguYyp0aGlzLm1hdHJpeC5iKTtcbiAgICBjb25zdCB4ID0gKCB0aGlzLm1hdHJpeC5kKih0ci54IC0gdGhpcy5tYXRyaXgudHgpIC0gdGhpcy5tYXRyaXguYyoodHIueSAtIHRoaXMubWF0cml4LnR5KSApICogZGV0ICsgdGhpcy5jZW50ZXIueDtcbiAgICBjb25zdCB5ID0gKC10aGlzLm1hdHJpeC5iKih0ci54IC0gdGhpcy5tYXRyaXgudHgpICsgdGhpcy5tYXRyaXguYSoodHIueSAtIHRoaXMubWF0cml4LnR5KSApICogZGV0ICsgdGhpcy5jZW50ZXIueTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG5cbiAgdHJhbnNsYXRlKGN1cnJlbnQpe1xuICAgIC8v0L/QtdGA0LXRhdC+0LTQuNC8INCyINC70L7QutCw0LvRjNC90YPRjiDRgdC40YHRgtC10LzRgyDQutC+0YDQtNC40L3QsNGCXG4gICAgY29uc3Qgb3JpZ2luID0ge3g6IGN1cnJlbnQueCAtIHRoaXMuY2VudGVyLngsIHk6IGN1cnJlbnQueSAtIHRoaXMuY2VudGVyLnl9O1xuICAgIC8v0YDQsNGB0YHRh9C40YLQsNC10Lwg0YLRgNCw0L3RgdGE0L7RgNC80LDRhtC40Y4g0Lgg0LLQvtC30LLRgNCw0YnQsNC10LzRgdGPINCy0L4g0LLQvdC10YjQvdGO0Y4g0YHQuNGB0YLQtdC80YMg0LrQvtGA0LTQuNC90LDRglxuICAgIGxldCB4ID0gdGhpcy5tYXRyaXguYSpvcmlnaW4ueCArIHRoaXMubWF0cml4LmMqb3JpZ2luLnkgKyB0aGlzLm1hdHJpeC50eCArIHRoaXMuY2VudGVyLng7XG4gICAgbGV0IHkgPSB0aGlzLm1hdHJpeC5iKm9yaWdpbi54ICsgdGhpcy5tYXRyaXguZCpvcmlnaW4ueSArIHRoaXMubWF0cml4LnR5ICsgdGhpcy5jZW50ZXIueTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKGRlZywgbWF0cml4ID0gZmFsc2UpIHtcbiAgbGV0IHJvdGF0aW9uID0gZGVnJTM2MDtcbiAgaWYoZGVnIDwgMCkgcm90YXRpb24gPSAzNjAgKyByb3RhdGlvbjtcbiAgaWYocm90YXRpb24gPT0gMzYwKSByb3RhdGlvbiA9IDA7XG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0cml4KHRyYW5zZm9ybSkge1xuICBsZXQgc2NhbGVYID0gdHJhbnNmb3JtLmZsb3AgPyB0cmFuc2Zvcm0uem9vbSA6IHRyYW5zZm9ybS56b29tO1xuICBsZXQgc2NhbGVZID0gdHJhbnNmb3JtLmZsaXAgPyAtdHJhbnNmb3JtLnpvb20gOiB0cmFuc2Zvcm0uem9vbTtcbiAgbGV0IHR4ID0gdHJhbnNmb3JtLng7XG4gIGxldCB0eSA9IHRyYW5zZm9ybS55O1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyh0cmFuc2Zvcm0ucm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKHRyYW5zZm9ybS5yb3RhdGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgbGV0IGEgPSBNYXRoLnJvdW5kKGNvcykqc2NhbGVYO1xuICBsZXQgYiA9IE1hdGgucm91bmQoc2luKSpzY2FsZVg7XG4gIGxldCBjID0gLU1hdGgucm91bmQoc2luKSpzY2FsZVk7XG4gIGxldCBkID0gTWF0aC5yb3VuZChjb3MpKnNjYWxlWTtcblxuICAvL2Zsb3A6IGEgPCAwXG4gIC8vZmxpcDogZCA8IDBcbiAgLy9yb3RhdGU6IGEgPT0gMCAmJiBkID09IDBcblxuICByZXR1cm4geyBhLCBiLCBjLCBkLCB0eCwgdHkgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7IFByZXZpZXcgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaXA6IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9LFxuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIGltYWdlOiBudWxsLFxuICAgICAgaW1hZ2VSZWFkeTogZmFsc2UsXG4gICAgICBpbWFnZVJlY3Q6IHt9LFxuICAgICAgYXJlYVJlY3Q6IHt9LFxuICAgICAgbWluWm9vbVZhbHVlczoge30sXG4gICAgICBtaW5ab29tOiAwLjUsXG4gICAgICBtYXhab29tOiAyLFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgfSxcbiAgICAgICAgem9vbTogMSxcbiAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICBmbGlwOiBmYWxzZSxcbiAgICAgICAgZmxvcDogZmFsc2UsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBsb2FkZWRUcmFuc2Zvcm06IG51bGwsXG4gICAgICBuZXh0TG9hZGluZzogZmFsc2UsXG4gICAgICBmcmFtZTogJ2Fzc2V0cy9pbWFnZXMvZnJhbWUtcHJpbnRtZS13aGl0ZS5wbmcnXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG1hdHJpeCgpIHtcbiAgICAgIGxldCBzY2FsZVggPSB0aGlzLnRyYW5zZm9ybS5mbG9wID8gLXRoaXMudHJhbnNmb3JtLnpvb20gOiB0aGlzLnRyYW5zZm9ybS56b29tO1xuICAgICAgbGV0IHNjYWxlWSA9IHRoaXMudHJhbnNmb3JtLmZsaXAgPyAtdGhpcy50cmFuc2Zvcm0uem9vbSA6IHRoaXMudHJhbnNmb3JtLnpvb207XG4gICAgICBsZXQgdHggPSB0aGlzLnRyYW5zZm9ybS54O1xuICAgICAgbGV0IHR5ID0gdGhpcy50cmFuc2Zvcm0ueTtcbiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHRoaXMudHJhbnNmb3JtLnJvdGF0ZSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4odGhpcy50cmFuc2Zvcm0ucm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICBsZXQgYSA9IE1hdGgucm91bmQoY29zKSpzY2FsZVg7XG4gICAgICBsZXQgYiA9IE1hdGgucm91bmQoc2luKSpzY2FsZVg7XG4gICAgICBsZXQgYyA9IC1NYXRoLnJvdW5kKHNpbikqc2NhbGVZO1xuICAgICAgbGV0IGQgPSBNYXRoLnJvdW5kKGNvcykqc2NhbGVZO1xuXG4gICAgICByZXR1cm4geyBhLCBiLCBjLCBkLCB0eCwgdHkgfTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKXtcbiAgICB0aGlzLmltYWdlID0gJ2Fzc2V0cy9pbWFnZXMvZGVtby5qcGcnO1xuICB9LFxuICBtZXRob2RzOiB7XG5cbiAgICBpbWFnZUxvYWRlZChyZWN0KXtcbiAgICAgIHRoaXMuaW1hZ2VSZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLmltYWdlUmVjdCA9IHJlY3Q7XG4gICAgICB0aGlzLmltYWdlUmVjdCA9IHtcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHdpZHRoOiByZWN0LnNpemUud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiByZWN0LnNpemUuaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgIHg6IHJlY3QuY2VudGVyLngsXG4gICAgICAgICAgeTogcmVjdC5jZW50ZXIueVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZXRNaW5ab29tKCk7XG4gICAgICB0aGlzLl9zZXRNYXhab29tKCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybS56b29tID0gdGhpcy5taW5ab29tO1xuXG4gICAgICBpZih0aGlzLmxvYWRlZFRyYW5zZm9ybSkgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLmxvYWRlZFRyYW5zZm9ybTtcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfc2V0TWluWm9vbSgpe1xuICAgICAgbGV0IHJvdGF0ZSA9IHRoaXMubWF0cml4LmMgIT09IDA7XG4gICAgICBsZXQgaG9yaXpvbnRhbCA9IHRoaXMuaW1hZ2VSZWN0LnNpemUuaGVpZ2h0IDwgdGhpcy5pbWFnZVJlY3Quc2l6ZS53aWR0aDtcbiAgICAgIGxldCBhcmVhU2l6ZSA9IChob3Jpem9udGFsICYmICFyb3RhdGUgfHwgIWhvcml6b250YWwgJiYgcm90YXRlKSA/IHRoaXMuYXJlYVJlY3Quc2l6ZS53aWR0aCA6IHRoaXMuYXJlYVJlY3Quc2l6ZS5oZWlnaHQ7XG4gICAgICBsZXQgaW1hZ2VTaXplID0gaG9yaXpvbnRhbCA/IHRoaXMuaW1hZ2VSZWN0LnNpemUud2lkdGggOiB0aGlzLmltYWdlUmVjdC5zaXplLmhlaWdodDtcblxuICAgICAgdGhpcy5taW5ab29tID0gYXJlYVNpemUvaW1hZ2VTaXplO1xuICAgICAgaWYodGhpcy50cmFuc2Zvcm0uem9vbSA8IHRoaXMubWluWm9vbSkgdGhpcy50cmFuc2Zvcm0uem9vbSA9IHRoaXMubWluWm9vbTtcbiAgICB9LFxuXG4gICAgX3NldE1heFpvb20oKXtcbiAgICAgIHRoaXMubWF4Wm9vbSA9IHRoaXMuYXJlYVJlY3Quc2l6ZS53aWR0aC9jb25maWcuaW1hZ2UubWluUmVzb2x1dGlvbjtcbiAgICAgIGlmKHRoaXMudHJhbnNmb3JtLnpvb20gPiB0aGlzLm1heFpvb20pIHRoaXMudHJhbnNmb3JtLnpvb20gPSB0aGlzLm1heFpvb207XG4gICAgfSxcblxuICAgIGFyZWFSZXNpemVkKHJlY3Qpe1xuICAgICAgdGhpcy5hcmVhUmVjdCA9IHJlY3Q7XG4gICAgICBpZih0aGlzLmltYWdlUmVhZHkpIHRoaXMuX3RyYW5zbGF0ZSgpO1xuICAgIH0sXG5cbiAgICBvblpvb21FbmQoKXtcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZSgpO1xuICAgIH0sXG5cbiAgICBmbGlwWCgpe1xuICAgICAgdGhpcy5tYXRyaXguYiA9PSAwICYmIHRoaXMubWF0cml4LmMgPT0gMFxuICAgICAgPyB0aGlzLnRyYW5zZm9ybS5mbGlwID0gIXRoaXMudHJhbnNmb3JtLmZsaXBcbiAgICAgIDogdGhpcy50cmFuc2Zvcm0uZmxvcCA9ICF0aGlzLnRyYW5zZm9ybS5mbG9wO1xuICAgIH0sXG5cbiAgICBmbGlwWSgpe1xuICAgICAgdGhpcy5tYXRyaXguYiA9PSAwICYmIHRoaXMubWF0cml4LmMgPT0gMFxuICAgICAgPyB0aGlzLnRyYW5zZm9ybS5mbG9wID0gIXRoaXMudHJhbnNmb3JtLmZsb3BcbiAgICAgIDogdGhpcy50cmFuc2Zvcm0uZmxpcCA9ICF0aGlzLnRyYW5zZm9ybS5mbGlwO1xuICAgIH0sXG5cbiAgICByb3RhdGVQbHVzKCl7XG4gICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGUgKz0gOTA7XG4gICAgICB0aGlzLl9zZXRNaW5ab29tKCk7XG4gICAgICB0aGlzLl90cmFuc2xhdGUoKTtcbiAgICB9LFxuXG4gICAgcm90YXRlTWludXMoKXtcbiAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0ZSAtPSA5MDtcbiAgICAgIHRoaXMuX3NldE1pblpvb20oKTtcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZSgpO1xuICAgIH0sXG5cbiAgICBpbWFnZU1vdmVkKHRyYW5zbGF0ZSl7XG4gICAgICB0aGlzLl90cmFuc2xhdGUoKTtcbiAgICB9LFxuXG4gICAgX3RyYW5zbGF0ZShjaGVja0FsaWduID0gdHJ1ZSl7XG4gICAgICBjb25zdCB0ciA9IG5ldyBUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB0aGlzLm1hdHJpeCk7XG5cbiAgICAgIC8v0L3QsNGF0L7QtNC40Lwg0LrQvtC+0YDQtNC40L3QsNGC0YssINC60L7RgtC+0YDRi9C1LCDQv9C+0YHQu9C1INGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNC4LCDQtNC+0LvQttC90Ysg0YHQvtCy0L/QsNGB0YLRjCDRgSDRhtC10L3RgtGA0L7QvCDQvtCx0LvQsNGB0YLQuCDQutGA0L7Qv9CwXG4gICAgICBjb25zdCBuZXdDZW50ZXIgPSB0ci5nZXRPcmlnaW5zKHRoaXMuYXJlYVJlY3QuY2VudGVyKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtLmNlbnRlciA9IG5ld0NlbnRlcjtcbiAgICAgIC8v0L/QtdGA0LXRgdGH0LjRgtGL0LLQsNC10Lwg0YHQvNC10YnQtdC90LjQtSDQtNC70Y8g0LrQvtC80L/QtdC90YHQsNGG0LjQuCDRgdC00LLQuNCz0LAg0YbQtdC90YLRgNCwXG4gICAgICB0aGlzLnRyYW5zZm9ybS54ID0gdGhpcy5hcmVhUmVjdC5jZW50ZXIueCAtIG5ld0NlbnRlci54O1xuICAgICAgdGhpcy50cmFuc2Zvcm0ueSA9IHRoaXMuYXJlYVJlY3QuY2VudGVyLnkgLSBuZXdDZW50ZXIueTtcblxuICAgICAgLy/QvtCx0L3QvtCy0LvRj9C10Lwg0LrQvtC+0YDQtNC40L3QsNGC0Ysg0YbQtdC90YLRgNCwXG4gICAgICB0ci5pbml0KHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdGhpcy5tYXRyaXgpO1xuXG4gICAgICAvL9GA0LDRgdGB0YfQuNGC0YvQstCw0LXQvCDQutC+0YDQtNC40L3QsNGC0Ysg0LLQtdGA0YXQvdC10LPQviDQu9C10LLQvtCz0L4g0Lgg0L3QuNC20L3QtdCz0L4g0L/RgNCw0LLQvtCz0L4g0YPQs9C70L7QsiDQuNC30L7QsdGA0LDQttC10L3QuNGPLCDQutC+0YLQvtGA0YvQtSDQv9C+0LvRg9GH0LjQu9C40YHRjCDQv9C+0YHQu9C1INC/0YDQuNC80LXQvdC10L3QuNGPINGC0YDQsNC90YHRhNC+0YDQvNCw0YbQuNC4XG4gICAgICBsZXQgeDB5MCA9IHRyLnRyYW5zbGF0ZSh7eDogMCwgeTogMH0pO1xuICAgICAgbGV0IHgxeTEgPSB0ci50cmFuc2xhdGUoe3g6IHRoaXMuaW1hZ2VSZWN0LnNpemUud2lkdGgsIHk6IHRoaXMuaW1hZ2VSZWN0LnNpemUuaGVpZ2h0fSk7XG5cbiAgICAgIC8v0L3QsNGF0L7QtNC40Lwg0YDQsNGB0L/QvtC70L7QttC10L3QuNC1ICjQvtGC0L3QvtGB0LjRgtC10LvRjNC90L4g0L7QsdC70LDRgdGC0Lgg0LrRgNC+0L/QsCkg0LrRgNCw0LnQvdC40YUg0YLQvtGH0LXQuiDQuNC30L7QsdGA0LDQttC10L3QuNGPINC4INC10LPQviDRgNCw0LfQvNC10YBcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGxlZnQ6IHgxeTEueCAtIHgweTAueCA+IDAgPyB4MHkwLnggOiB4MXkxLngsXG4gICAgICAgIHRvcDogeDF5MS55IC0geDB5MC55ID4gMCA/IHgweTAueSA6IHgxeTEueSxcbiAgICAgICAgd2lkdGg6IE1hdGguYWJzKHgxeTEueCAtIHgweTAueCksXG4gICAgICAgIGhlaWdodDogTWF0aC5hYnMoeDF5MS55IC0geDB5MC55KVxuICAgICAgfTtcblxuICAgICAgLy/QvdCw0YXQvtC00LjQvCDRgdC80LXRidC10L3QuNGPINC+0YLQvdC+0YHQuNGC0LXQu9GM0L3QviDQvtCx0LvQsNGB0YLQuCDQutGA0L7Qv9CwINC4INCy0YvRgNCw0LLQvdC40LLQsNC10Lwg0LjQt9C+0LHRgNCw0LbQtdC90LjQtSwg0LXRgdC70Lgg0L/QvtGP0LLQuNC70LjRgdGMIFwi0LfQsNC30L7RgNGLXCJcbiAgICAgIC8vYWxpZ24gZnVuY3Rpb25zXG4gICAgICBsZXQgcmlnaHRPZmZzZXQgPSB0aGlzLmFyZWFSZWN0LnNpemUud2lkdGggLSAocmVzdWx0LmxlZnQgKyByZXN1bHQud2lkdGgpO1xuICAgICAgbGV0IGJvdHRvbU9mZnNldCA9IHRoaXMuYXJlYVJlY3Quc2l6ZS5oZWlnaHQgLSAocmVzdWx0LnRvcCArIHJlc3VsdC5oZWlnaHQpO1xuXG4gICAgICBsZXQgYWxpZ25lZENlbnRlcjtcblxuXG4gICAgICAvL9Cy0YvRgNCw0LnQvdC40LLQsNC10Lwg0L/QviDQs9C+0YDQuNC30L7QvdGC0LDQu9C4XG4gICAgICBpZih0aGlzLmFyZWFSZWN0LnNpemUud2lkdGggLSByZXN1bHQud2lkdGggPiAxKXtcbiAgICAgICAgLy9hbGlnbiBjZW50ZXIgWFxuICAgICAgICBhbGlnbmVkQ2VudGVyID0gdHIuZ2V0T3JpZ2lucyh7eDogcmVzdWx0LmxlZnQgKyByZXN1bHQud2lkdGgvMiwgeTogdGhpcy5hcmVhUmVjdC5jZW50ZXIueX0pO1xuICAgICAgfWVsc2V7XG4gICAgICAgIC8vYWxpZ24gbGVmdFxuICAgICAgICBpZihyZXN1bHQubGVmdCA+IDApe1xuICAgICAgICAgIGFsaWduZWRDZW50ZXIgPSB0ci5nZXRPcmlnaW5zKHt4OiByZXN1bHQubGVmdCArIHRoaXMuYXJlYVJlY3QuY2VudGVyLngsIHk6IHRoaXMuYXJlYVJlY3QuY2VudGVyLnl9KTtcbiAgICAgICAgLy9hbGlnbiByaWdodFxuICAgICAgICB9ZWxzZSBpZihyaWdodE9mZnNldCA+IDApe1xuICAgICAgICAgIGFsaWduZWRDZW50ZXIgPSB0ci5nZXRPcmlnaW5zKHt4OiB0aGlzLmFyZWFSZWN0LmNlbnRlci54IC0gcmlnaHRPZmZzZXQsIHk6IHRoaXMuYXJlYVJlY3QuY2VudGVyLnl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihhbGlnbmVkQ2VudGVyKXtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uY2VudGVyID0gYWxpZ25lZENlbnRlcjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ueCA9IHRoaXMuYXJlYVJlY3QuY2VudGVyLnggLSBhbGlnbmVkQ2VudGVyLng7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnkgPSB0aGlzLmFyZWFSZWN0LmNlbnRlci55IC0gYWxpZ25lZENlbnRlci55O1xuICAgICAgICB0ci5pbml0KHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICAvL9Cy0YvRgNCw0LnQvdC40LLQsNC10Lwg0L/QviDQstC10YDRgtC40LrQsNC70LhcbiAgICAgIGlmKHRoaXMuYXJlYVJlY3Quc2l6ZS5oZWlnaHQgLSByZXN1bHQuaGVpZ2h0ID4gMSl7XG4gICAgICAgIC8vYWxpZ24gY2VudGVyIFlcbiAgICAgICAgYWxpZ25lZENlbnRlciA9IHRyLmdldE9yaWdpbnMoe3g6IHRoaXMuYXJlYVJlY3QuY2VudGVyLngsIHk6IHJlc3VsdC50b3AgKyByZXN1bHQuaGVpZ2h0LzJ9KTtcbiAgICAgIH1lbHNle1xuICAgICAgICAvL2FsaWduIHRvcFxuICAgICAgICBpZihyZXN1bHQudG9wID4gMCl7XG4gICAgICAgICAgYWxpZ25lZENlbnRlciA9IHRyLmdldE9yaWdpbnMoe3g6IHRoaXMuYXJlYVJlY3QuY2VudGVyLngsIHk6IHJlc3VsdC50b3AgKyB0aGlzLmFyZWFSZWN0LmNlbnRlci55fSk7XG4gICAgICAgIC8vYWxpZ24gYm90dG9tXG4gICAgICAgIH1lbHNlIGlmKGJvdHRvbU9mZnNldCA+IDApe1xuICAgICAgICAgIGFsaWduZWRDZW50ZXIgPSB0ci5nZXRPcmlnaW5zKHt4OiB0aGlzLmFyZWFSZWN0LmNlbnRlci54LCB5OiB0aGlzLmFyZWFSZWN0LmNlbnRlci55IC0gYm90dG9tT2Zmc2V0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoYWxpZ25lZENlbnRlcil7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmNlbnRlciA9IGFsaWduZWRDZW50ZXI7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnggPSB0aGlzLmFyZWFSZWN0LmNlbnRlci54IC0gYWxpZ25lZENlbnRlci54O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS55ID0gdGhpcy5hcmVhUmVjdC5jZW50ZXIueSAtIGFsaWduZWRDZW50ZXIueTtcbiAgICAgICAgdHIuaW5pdCh0aGlzLnRyYW5zZm9ybS5jZW50ZXIsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1cGRhdGVJbWFnZSgpe1xuICAgICAgY29uc3QgdHIgPSBuZXcgVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdGhpcy5tYXRyaXgpO1xuICAgICAgbGV0IHRvcExlZnQgPSB0ci5nZXRPcmlnaW5zKHt4OiAwLCB5OiAwfSk7XG4gICAgICBsZXQgYm90dG9tUmlnaHQgPSB0ci5nZXRPcmlnaW5zKHt4OiB0aGlzLmFyZWFSZWN0LnNpemUud2lkdGgsIHk6IHRoaXMuYXJlYVJlY3Quc2l6ZS5oZWlnaHR9KTtcblxuICAgICAgY29uc3QgbGVmdCA9IHRvcExlZnQueCA8IGJvdHRvbVJpZ2h0LnggPyBNYXRoLnJvdW5kKHRvcExlZnQueCkgOiBNYXRoLnJvdW5kKGJvdHRvbVJpZ2h0LngpO1xuICAgICAgY29uc3QgdG9wID0gdG9wTGVmdC55IDwgYm90dG9tUmlnaHQueSA/IE1hdGgucm91bmQodG9wTGVmdC55KSA6IE1hdGgucm91bmQoYm90dG9tUmlnaHQueSk7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoTWF0aC5hYnMoYm90dG9tUmlnaHQueCAtIHRvcExlZnQueCkpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChNYXRoLmFicyhib3R0b21SaWdodC55IC0gdG9wTGVmdC55KSk7XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgIGNyb3A6IHtcbiAgICAgICAgICBzaXplOiB0aGlzLmltYWdlUmVjdC5zaXplLFxuICAgICAgICAgIG9yaWdpbmFsOiB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICBmbGlwOiB0aGlzLnRyYW5zZm9ybS5mbGlwLFxuICAgICAgICAgIGZsb3A6IHRoaXMudHJhbnNmb3JtLmZsb3AsXG4gICAgICAgICAgcm90YXRlOiB0aGlzLnRyYW5zZm9ybS5yb3RhdGUsXG4gICAgICAgICAgY3JvcDogeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm5leHRMb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgY29uc29sZS5sb2coZGF0YSlcbiAgICAgIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuICAgICAgLy9zb21lIEFQSVxuXG4gICAgICB0aGlzLm5leHRMb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImNzc1wiPlxuICAub3ZlcmZsb3cge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gY2xpZW50L2FwcC9wYWdlcy9lZGl0LnZ1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ })

})